{
  "language": "Solidity",
  "sources": {
    "contracts/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Profile {\n\n    struct Driver {\n        bool isDriver;          \n        uint256 rate;           // Driver rate \n        string carAssetUrl;     // Car image and description ie number of seats available, pointing towards storacha\n        string infoAssetUrl;    // Driver image, name , age pointing towards storacha database\n        uint256 counterCourse;\n        string zkPassport; \n    }\n\n    struct Passenger {\n        bool isPassenger;          \n        uint256 rate;           // Passenger rate \n        string infoAssetUrl;    // Passenger image, name , age pointing towards storacha database\n        uint256 counterCourse;\n        string zkPassport; \n    }\n\n    event DriverAdded(address indexed account);\n    event DriverRemoved(address indexed account);\n    event PassengerAdded(address indexed account); \n    event PassengerRemoved(address indexed account);\n\n    mapping(address => Driver) private drivers;\n    mapping(address => Passenger) private passengers;\n\n    // Define modifiers that checks to see if msg.sender has the appropriate role\n    modifier onlyDriver() {\n        require(isDriver(msg.sender), \"Sender isn't a driver\");\n        _;\n    }\n\n    modifier onlyPassenger() {\n        require(isPassenger(msg.sender), \"Sender isn't a passenger\");\n        _;\n    }\n\n    function addDriver(uint256 _startingRate, string memory _carAssetUrl, string memory _profileAssetUrl) \n        public \n    {\n        require(!isDriver(msg.sender), \"Sender is already a driver\");\n        Driver memory driverDetails;\n        driverDetails.isDriver = true;\n        driverDetails.counterCourse = 0; \n        driverDetails.rate = _startingRate;\n        driverDetails.carAssetUrl = _carAssetUrl;\n        driverDetails.infoAssetUrl = _profileAssetUrl;\n        drivers[msg.sender] = driverDetails;\n        emit DriverAdded(msg.sender);\n    }\n\n    function addPassenger(uint256 _startingRate, string memory _profileAssetUrl) \n        public \n    {\n        require(!isPassenger(msg.sender), \"Sender is already a passenger\");\n        Passenger memory passengerDetail;\n        passengerDetail.isPassenger = true;\n        passengerDetail.counterCourse = 0; \n        passengerDetail.rate = _startingRate;\n        passengerDetail.infoAssetUrl = _profileAssetUrl;\n        passengers[msg.sender] = passengerDetail;\n        emit PassengerAdded(msg.sender);\n    }\n\n    function removePassenger() \n        public\n        onlyPassenger\n    {\n        delete passengers[msg.sender];\n        emit PassengerRemoved(msg.sender);\n    }\n\n    function removeDriver() \n        public\n        onlyDriver\n    {\n        delete drivers[msg.sender];\n        emit DriverRemoved(msg.sender);\n    }\n\n    function updateRate(uint256 _newRate, address _account, bool _isDriver) \n        public \n    {\n        if (_isDriver) {\n            require(isPassenger(msg.sender), \"Sender isn't a passenger\");\n            Driver memory driverDetails = drivers[_account];\n            driverDetails.rate = _newRate;\n            drivers[_account] = driverDetails; \n        } else {\n            require(isDriver(msg.sender), \"Sender isn't a driver\");\n            Passenger memory passengerDetails = passengers[_account];\n            passengerDetails.rate = _newRate;\n            passengers[_account] = passengerDetails; \n        }\n    }\n\n    function isDriver(address account) public view returns (bool) {\n        return drivers[account].isDriver;\n    }\n\n    function isPassenger(address account) public view returns (bool) {\n        return passengers[account].isPassenger;\n    }\n\n    function getDriver(address account) public view returns (Driver memory) {\n        return drivers[account];\n    }\n\n    function getPassenger(address account) public view returns (Passenger memory) {\n        return passengers[account];\n    }\n\n    function getDriverRate(address account) public view returns (uint256) {\n        return drivers[account].rate;\n    }\n\n    function getPassengerRate(address account) public view returns (uint256) {\n        return passengers[account].rate;\n    }\n\n    function getDriverCounter(address account) public view returns (uint256) {\n        return drivers[account].counterCourse;\n    }\n\n    function getPassengerCounter(address account) public view returns (uint256) {\n        return passengers[account].counterCourse;\n    }\n}"
    },
    "contracts/RideManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Profile.sol\";\n\n/**\n * @title RideManagement\n * @dev This contract manages rides, including their states and details. It provides functionality for posting, booking, and completing rides.\n */\ncontract RideManagement {\n    Ride[] private _rides;\n    mapping(bytes32 => uint256) private _rideIndexMap;\n    uint256 private _rideCount = 0;\n\n    enum RideState {\n        Posted,\n        Booked,\n        Completed,\n        Canceled\n    }\n\n    struct Ride {\n        bytes32 id;\n        RideState state;\n        address owner;\n        address[] passengers;\n        uint256 price;\n        uint256 timestamp;\n        uint256 totalSeats;\n        uint256 availableSeats;\n        string destination;\n    }\n\n    event RidePosted(bytes32 indexed rideId, address indexed owner);\n    event RideBooked(bytes32 indexed rideId, address indexed passenger);\n    event RideCompleted(bytes32 indexed rideId);\n    event RideCanceled(bytes32 indexed rideId);\n\n    modifier onlyOwner(bytes32 rideId) {\n        require(_rides[_rideIndexMap[rideId]].owner == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n\n    function postRide(uint256 price, uint256 totalSeats, string memory destination) public {\n        bytes32 rideId = keccak256(abi.encodePacked(msg.sender, block.timestamp, _rideCount));\n        Ride memory newRide = Ride({\n            id: rideId,\n            state: RideState.Posted,\n            owner: msg.sender,\n            passengers: new address[](0),\n            price: price,\n            timestamp: block.timestamp,\n            totalSeats: totalSeats,\n            availableSeats: totalSeats,\n            destination: destination\n        });\n        _rides.push(newRide);\n        _rideIndexMap[rideId] = _rideCount;\n        _rideCount++;\n        emit RidePosted(rideId, msg.sender);\n    }\n\n    function bookRide(bytes32 rideId) public {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Posted, \"Ride is not available for booking\");\n        require(ride.availableSeats > 0, \"No available seats\");\n        ride.passengers.push(msg.sender);\n        ride.availableSeats--;\n        if (ride.availableSeats == 0) {\n            ride.state = RideState.Booked;\n        }\n        emit RideBooked(rideId, msg.sender);\n    }\n\n    function completeRide(bytes32 rideId) public onlyOwner(rideId) {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Booked, \"Ride is not booked\");\n        ride.state = RideState.Completed;\n        emit RideCompleted(rideId);\n    }\n\n    function cancelRide(bytes32 rideId) public onlyOwner(rideId) {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Posted || ride.state == RideState.Booked, \"Ride cannot be canceled\");\n        ride.state = RideState.Canceled;\n        emit RideCanceled(rideId);\n    }\n\n    function getRide(bytes32 rideId) public view returns (Ride memory) {\n        return _rides[_rideIndexMap[rideId]];\n    }\n\n    function getAllRides() public view returns (Ride[] memory) {\n        return _rides;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}