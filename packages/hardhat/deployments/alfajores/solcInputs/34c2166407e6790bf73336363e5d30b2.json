{
  "language": "Solidity",
  "sources": {
    "contracts/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Profile {\n\n    struct Driver {\n        bool isDriver;          \n        uint256 rating;           // Driver rating(score) \n        string carAssetUrl;     // Car image and description ie number of seats available, pointing towards storacha\n        string infoAssetUrl;    // Driver image, name , age pointing towards storacha database\n        uint256 counterCourse;\n        string zkPassport; \n    }\n\n    struct Passenger {\n        bool isPassenger;          \n        uint256 rating;           // Passenger rating(score) \n        string infoAssetUrl;    // Passenger image, name , age pointing towards storacha database\n        uint256 counterCourse;\n        string zkPassport; \n    }\n\n    event DriverAdded(address indexed account);\n    event DriverRemoved(address indexed account);\n    event PassengerAdded(address indexed account); \n    event PassengerRemoved(address indexed account);\n\n    mapping(address => Driver) private drivers;\n    mapping(address => Passenger) private passengers;\n\n    // Define modifiers that checks to see if msg.sender has the appropriate role\n    modifier onlyDriver() {\n        require(isDriver(msg.sender), \"Sender isn't a driver\");\n        _;\n    }\n\n    modifier onlyPassenger() {\n        require(isPassenger(msg.sender), \"Sender isn't a passenger\");\n        _;\n    }\n\n    function addDriver(uint256 _initialRating, string memory _carAssetUrl, string memory _profileAssetUrl) \n        public \n    {\n        require(!isDriver(msg.sender), \"Sender is already a driver\");\n        Driver memory driverDetails;\n        driverDetails.isDriver = true;\n        driverDetails.counterCourse = 0; \n        driverDetails.rating = _initialRating;\n        driverDetails.carAssetUrl = _carAssetUrl;\n        driverDetails.infoAssetUrl = _profileAssetUrl;\n        drivers[msg.sender] = driverDetails;\n        emit DriverAdded(msg.sender);\n    }\n\n    function addPassenger(uint256 _initialRating, string memory _profileAssetUrl) \n        public \n    {\n        require(!isPassenger(msg.sender), \"Sender is already a passenger\");\n        Passenger memory passengerDetail;\n        passengerDetail.isPassenger = true;\n        passengerDetail.counterCourse = 0; \n        passengerDetail.rating = _initialRating;\n        passengerDetail.infoAssetUrl = _profileAssetUrl;\n        passengers[msg.sender] = passengerDetail;\n        emit PassengerAdded(msg.sender);\n    }\n\n    function removePassenger() \n        public\n        onlyPassenger\n    {\n        delete passengers[msg.sender];\n        emit PassengerRemoved(msg.sender);\n    }\n\n    function removeDriver() \n        public\n        onlyDriver\n    {\n        delete drivers[msg.sender];\n        emit DriverRemoved(msg.sender);\n    }\n\n    function updateRate(uint256 _newRate, address _account, bool _isDriver) \n        public \n    {\n        if (_isDriver) {\n            require(isPassenger(msg.sender), \"Sender isn't a passenger\");\n            Driver memory driverDetails = drivers[_account];\n            driverDetails.rating = _newRate;\n            drivers[_account] = driverDetails; \n        } else {\n            require(isDriver(msg.sender), \"Sender isn't a driver\");\n            Passenger memory passengerDetails = passengers[_account];\n            passengerDetails.rating = _newRate;\n            passengers[_account] = passengerDetails; \n        }\n    }\n\n    function isDriver(address account) public view returns (bool) {\n        return drivers[account].isDriver;\n    }\n\n    function isPassenger(address account) public view returns (bool) {\n        return passengers[account].isPassenger;\n    }\n\n    function getDriver(address account) public view returns (Driver memory) {\n        return drivers[account];\n    }\n\n    function getPassenger(address account) public view returns (Passenger memory) {\n        return passengers[account];\n    }\n\n    function getDriverRate(address account) public view returns (uint256) {\n        return drivers[account].rating;\n    }\n\n    function getPassengerRate(address account) public view returns (uint256) {\n        return passengers[account].rating;\n    }\n\n    function getDriverCounter(address account) public view returns (uint256) {\n        return drivers[account].counterCourse;\n    }\n\n    function getPassengerCounter(address account) public view returns (uint256) {\n        return passengers[account].counterCourse;\n    }\n}"
    },
    "contracts/RideManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Profile.sol\";\n\n/**\n * @title RideManagement\n * @dev This contract manages rides, including their states and details. It provides functionality for posting, booking, and completing rides.\n */\ncontract RideManagement {\n    Ride[] private _rides;\n    mapping(bytes32 => uint256) private _rideIndexMap;\n    uint256 private _rideCount = 0;\n\n    /**\n     * @dev Enum representing the various states a ride can be in.\n     */\n    enum RideState {\n        Pending,      // Ride has been posted but not yet confirmed by the driver\n        Posted,       // Ride has been confirmed by the driver and is available for booking\n        Booked,       // Ride has been booked by a passenger\n        InProgress,   // Ride is currently in progress\n        Completed,    // Ride has been completed\n        Canceled,     // Ride has been canceled\n        Failed        // Ride has failed or been interrupted\n    }\n\n    /**\n     * @dev Struct representing a ride.\n     */\n    struct Ride {\n        bytes32 id;\n        RideState state;\n        address owner;\n        address[] passengers;\n        uint256 price;\n        uint256 timestamp;\n        uint256 totalSeats;\n        uint256 availableSeats;\n        string destination;\n    }\n\n    event RidePosted(bytes32 indexed rideId, address indexed owner);\n    event RideBooked(bytes32 indexed rideId, address indexed passenger);\n    event RideCompleted(bytes32 indexed rideId);\n    event RideCanceled(bytes32 indexed rideId);\n\n    modifier onlyOwner(bytes32 rideId) {\n        require(_rides[_rideIndexMap[rideId]].owner == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Function to post a new ride. Sets the initial state to Pending.\n     */\n    function postRide(uint256 price, uint256 totalSeats, string memory destination) public {\n        bytes32 rideId = keccak256(abi.encodePacked(msg.sender, block.timestamp, _rideCount));\n        Ride memory newRide = Ride({\n            id: rideId,\n            state: RideState.Pending,  // Set initial state to Pending\n            owner: msg.sender,\n            passengers: new address[](0),\n            price: price,\n            timestamp: block.timestamp,\n            totalSeats: totalSeats,\n            availableSeats: totalSeats,\n            destination: destination\n        });\n        _rides.push(newRide);\n        _rideIndexMap[rideId] = _rideCount;\n        _rideCount++;\n        emit RidePosted(rideId, msg.sender);\n    }\n\n    /**\n     * @dev Function for the driver to confirm a ride. Changes state from Pending to Posted.\n     */\n    function confirmRide(bytes32 rideId) public onlyOwner(rideId) {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Pending, \"Ride is not in pending state\");\n        ride.state = RideState.Posted;\n        emit RidePosted(ride.id, ride.owner);\n    }\n\n    /**\n     * @dev Function for a passenger to book a ride. Changes state from Posted to Booked if no available seats remain.\n     */\n    function bookRide(bytes32 rideId) public {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Posted, \"Ride is not available for booking\");\n        require(ride.availableSeats > 0, \"No available seats\");\n        ride.passengers.push(msg.sender);\n        ride.availableSeats--;\n        if (ride.availableSeats == 0) {\n            ride.state = RideState.Booked;\n        }\n        emit RideBooked(rideId, msg.sender);\n    }\n\n    /**\n     * @dev Function for the driver to mark a ride as completed. Changes state from Booked to Completed.\n     */\n    function completeRide(bytes32 rideId) public onlyOwner(rideId) {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Booked, \"Ride is not booked\");\n        ride.state = RideState.Completed;\n        emit RideCompleted(rideId);\n    }\n\n    /**\n     * @dev Function for the driver to cancel a ride. Can be called in Pending, Posted, or Booked states.\n     */\n    function cancelRide(bytes32 rideId) public onlyOwner(rideId) {\n        Ride storage ride = _rides[_rideIndexMap[rideId]];\n        require(ride.state == RideState.Pending || ride.state == RideState.Posted || ride.state == RideState.Booked, \"Ride cannot be canceled\");\n        ride.state = RideState.Canceled;\n        emit RideCanceled(rideId);\n    }\n\n    function getRide(bytes32 rideId) public view returns (Ride memory) {\n        return _rides[_rideIndexMap[rideId]];\n    }\n\n    function getAllRides() public view returns (Ride[] memory) {\n        return _rides;\n    }\n}"
    },
    "contracts/TransactionwAttestation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAttestationService {\n    function attest(address user, string calldata data) external;\n    function getAttestations(address user) external view returns (string[] memory);\n}\n\ncontract TransportWithAttestation {\n    IAttestationService public attestationService;\n\n    struct Request {\n        address requester;\n        address serviceProvider;\n        uint paymentAmount;\n        bool completed;\n    }\n\n    mapping(uint => Request) public requests;\n    uint public requestCount;\n\n    mapping(address => uint) public ratings;\n    mapping(address => uint) public ratingCounts;\n\n    event RequestCreated(uint requestId, address requester, uint paymentAmount);\n    event RequestCompleted(uint requestId, uint rating);\n\n    constructor(address _attestationService) {\n        attestationService = IAttestationService(_attestationService);\n    }\n\n    modifier onlyRequester(uint requestId) {\n        require(requests[requestId].requester == msg.sender, \"Caller is not the requester\");\n        _;\n    }\n\n    modifier onlyServiceProvider(uint requestId) {\n        require(requests[requestId].serviceProvider == msg.sender, \"Caller is not the service provider\");\n        _;\n    }\n\n    /**\n     * @dev Function to create a new request.\n     * @param serviceProvider The address of the service provider.\n     * @param paymentAmount The amount to be paid for the service.\n     */\n    function createRequest(address serviceProvider, uint paymentAmount) public {\n        requestCount++;\n        requests[requestCount] = Request({\n            requester: msg.sender,\n            serviceProvider: serviceProvider,\n            paymentAmount: paymentAmount,\n            completed: false\n        });\n        emit RequestCreated(requestCount, msg.sender, paymentAmount);\n    }\n\n    /**\n     * @dev Function for the service provider to complete a request.\n     * @param requestId The ID of the request to be completed.\n     * @param rating The rating given to the service provider.\n     */\n    function completeRequest(uint requestId, uint rating) public onlyServiceProvider(requestId) {\n        Request storage request = requests[requestId];\n        require(!request.completed, \"Request is already completed\");\n        request.completed = true;\n        ratings[request.serviceProvider] += rating;\n        ratingCounts[request.serviceProvider]++;\n        emit RequestCompleted(requestId, rating);\n        attestationService.attest(request.serviceProvider, \"Request completed with rating\");\n    }\n\n    /**\n     * @dev Function to get the average rating of a user.\n     * @param user The address of the user.\n     * @return The average rating of the user.\n     */\n    function getAverageRating(address user) public view returns (uint) {\n        if (ratingCounts[user] == 0) {\n            return 0;\n        }\n        return ratings[user] / ratingCounts[user];\n    }\n\n    /**\n     * @dev Function to get the details of a request.\n     * @param requestId The ID of the request.\n     * @return The details of the request.\n     */\n    function getRequest(uint requestId) public view returns (Request memory) {\n        return requests[requestId];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}